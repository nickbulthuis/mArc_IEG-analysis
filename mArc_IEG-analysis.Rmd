---
title: "mArc: IEG analysis"
author: "Nick Bulthuis, Columbia University"
output:
    html_document:
      toc: TRUE
      toc_float: TRUE
      number_sections: TRUE
      highlight: tango
      smart: TRUE
      theme: cosmo
      df_print: paged
editor_options: 
  chunk_output_type: console
---

# **Set up**

Install packages if needed (code not run by default).

```{r install.packages, eval = FALSE}

#install packages
  install.packages("yaml")
  install.packages("knitr")
  install.packages("hdf5r")
  install.packages("Seurat")
  install.packages("scCustomize", repos = c(CRAN = "https://cloud.r-project.org")) #to work around a funky install of Cairo
  install.packages("BiocManager")
    install.packages("xgboost", repos = c('https://dmlc.r-universe.dev', 'https://cloud.r-project.org')) #needed for scDblFinder
    BiocManager::install("scDblFinder")
    BiocManager::install("glmGamPoi") #used by SCTransform to improve speed
  install.packages("tidyverse")
  install.packages("harmony")
  install.packages("devtools")
    devtools::install_github("immunogenomics/presto") #used by Seurat for finding markers (faster Wilcoxon implementation)
  install.packages("pracma")
  install.packages("anndata") #exporting, to be used by MapMyCells
  install.packages("ggrepel") #prettier volcano plot labels
  install.packages("eulerr") #Venn diagrams
  
```

Initialize options for HTML knitting.

```{r knitr.opts}

knitr::opts_chunk$set(eval = TRUE, #evaluate all chunks unless set otherwise
                    	echo = TRUE, #show all chunks unless set otherwise
                    	message = FALSE, #don't show messages
                    	warning = FALSE, #don't show warnings
                    	collapse = TRUE, #collapse output blocks into one per chunk
                    	results = "hold", #hold all results until the end of the chunk
                    	fig.show = "hold", #hold figs too
                    	fig.dim = c(10, 10))

```

Load the libraries needed.

```{r load.libraries}

#analysis tools
  library(hdf5r)
  library(Seurat)
  library(scCustomize)
  library(reticulate)
  library(scDblFinder)
  library(MASS)
  library(Matrix)
  library(glmGamPoi)
  library(harmony)
  library(cluster)
  library(pracma)
  library(presto)
  library(readr)
  library(anndata)

#layout and formatting
  library(tidyverse)
  library(cowplot)
  library(gridExtra)
  library(scales)
  library(glue)
  library(ggrepel)
  library(eulerr)

```

Clean the environment and set the working drive. Change as needed to reproduce.

```{r clean.setwd}

#clean environment
  rm(list = ls())

#set working drive
  setwd("D:/NICK")
  knitr::opts_knit$set(root.dir = "D:/NICK") #use this alongside setwd() for better HTML knitting

```

# **Load data**

To start, load data from this study, located here: *[[link]]* 

To reproduce, adjust file paths below for your local environment.

```{r load}

#populate sample info, to be used for data loading (set manually)
  samples <- data.frame(file.path =   c("data/CN001_raw_feature_bc_matrix.h5",
                                        "data/CN002_raw_feature_bc_matrix.h5",
                                        "data/CN003_raw_feature_bc_matrix.h5",
                                        "data/CN004_raw_feature_bc_matrix.h5",
                                        "data/CN005_raw_feature_bc_matrix.h5",
                                        "data/CN006_raw_feature_bc_matrix.h5"),
                        sample.name = c("CN001", "CN002", "CN003", "CN004", "CN005", "CN006"),
                        rep.num =     c("6d R1", "6d R1", "6d R2", "6d R2", "6d R3", "6d R3"),
                        sort.cat =    c("GFP+", "GFP-", "GFP-", "GFP+", "GFP-", "GFP+"))

#initialize container list
  SampleList <- list()

#run through the sample df to load each one
  for (i in 1:dim(samples)[1]) {
    #read in the raw data & convert to Seurat object
    SampleList[[i]] <- Read10X_h5(samples[i, "file.path"], use.names = TRUE, unique.features = TRUE)
    SampleList[[i]] <- CreateSeuratObject(counts = SampleList[[i]], #unnormalized raw counts
                                          project = samples[i, "sample.name"], #set project name
                                          assay = "RNA", min.cells = 0, min.features = 0) #not filtering any genes or features out
    SampleList[[i]]$replicate <- samples[i, "rep.num"] #add replicate number
    SampleList[[i]]$sort <- samples[i, "sort.cat"] #add sort (GFP+ vs. GFP-)
    print(glue("Load: Sample {i} is done. # of droplets: {dim(SampleList[[i]])[2]}"))
  }
  rm(i, samples)
  
```

# **Quality control**

## *QC1: Transcript counts*

First QC step: filter out any droplets with low UMI counts, which indicate empty or poorly-profiled cells.

**UMI \# cutoff:** `1,000`

```{r QC1.UMI}

#set transcript/UMI count cutoff a priori
  cutoff.UMI = 1000

#run through samples to retain only cells with UMI count ≥ cutoff
  for (i in seq_along(SampleList)) { 
    SampleList[[i]] <- subset(SampleList[[i]], subset = nCount_RNA >= cutoff.UMI)
    print(glue("QC1: Sample {i} done. # of nuclei: {dim(SampleList[[i]])[2]}"))
  }
  rm(i, cutoff.UMI)
  
```

## *QC2: Mt gene fraction*

Second QC step: remove nuclei with too high a proportion of mitochondrial genes among all genes detected, indicating dying cells or nuclear contamination.

**Mito. cutoff:** `0.05` (`5%`)

```{r QC2.mito}

#set %MT cutoff a priori
  cutoff.MT = 0.05

#run through samples to apply filter
  for (i in seq_along(SampleList)) { 
    #assign %MT for each cell, counting up mito genes from "mt-" prefix
    SampleList[[i]][["percent.mt"]] <- PercentageFeatureSet(SampleList[[i]], pattern = "^mt-")
    #subset to retain only cells with percent.mt ≤ cutoff
    SampleList[[i]] <- subset(SampleList[[i]], subset = percent.mt <= cutoff.MT)
    print(glue("QC2: Sample {i} done. # of intact nuclei: {dim(SampleList[[i]])[2]}"))
  }
  rm(i, cutoff.MT)
  
```

## *QC3: Doublets*

Last QC step: remove nuclei suspected of being doublets (2 or more nuclei caught in same droplet).

**Doublet chance cutoff:** `0.50` (using function `scDblFinder()`)

```{r QC3.doublet}

#set cutoff for the probability of being a doublet a priori
  cutoff.dbl = 0.5

#run through the sample list to apply filter
  suppressWarnings( #suppress irrelevant warnings
  for (i in seq_along(SampleList)) { 
    
  #convert Seurat to SingleCellExperiment (sce) object & run scDblFinder
    set.seed(0) #set random seed for reproducibility
    QC.dbl <- scDblFinder(as.SingleCellExperiment(SampleList[[i]])) #run finder & store as new sce
    dbl.scores <- as.data.frame(QC.dbl$scDblFinder.score) #strip down to df of only doublet probability score
    rownames(dbl.scores) <- colnames(SampleList[[i]]) #add barcodes to new df to align data
    SampleList[[i]]$S.dbl <- dbl.scores
    #subset to retain only nuclei with doublet score below cutoff
    SampleList[[i]] <- subset(SampleList[[i]], subset = S.dbl < cutoff.dbl)
    print(glue("\tQC3: Sample {i} done. # of singlet intact nuclei: {dim(SampleList[[i]])[2]}"))
    rm(QC.dbl, dbl.scores)
  })
  rm(i, cutoff.dbl)

```

# **Integrating samples**

## *Step 1: Normalization*

Now that samples are filtered, combine them all together into one Seurat object by normalizing & integrating.

First: apply `SCTransform()`, which normalizes data, scales data, and finds variable features all in one, and is validated across platforms and sequencing depths (Choudhary & Satija, 2022, *Genome Biol.*).

```{r integrate1.normalize}

#SCTransform all samples individually
  for (i in seq_along(SampleList)) { 
    SampleList[[i]] <- SCTransform(SampleList[[i]])
    print(glue("\tNormalize: Sample {i} done."))
  }
  rm(i)

```

## *Step 2: Integration*

Next: integrate samples with Harmony, selected based on recent benchmarking tests (Luecken et al., 2022, *Nat. Methods*). Harmony is one of the top performers available in R, with robust documentation, high usability, and high performance on smaller/simpler integration tasks like this one (not integrating across platforms/multi-omics/etc., just samples).

```{r integrate2.harmonize}

#merge filtered Seurat objects into one combined Seurat
  HPC <- merge(x = SampleList[[1]], y = SampleList[2:length(SampleList)], #`merge()` only has two input slots, x and y
               add.cell.ids = as.character(1:length(SampleList)), #add sample # at the start of barcode
               merge.data = TRUE) #merge the data layer too
  HPC$sample <- HPC$orig.ident #copy sample info from `orig.ident` to `sample` for easier use

#assign top 3,000 variable features to Seurat by selecting from list of all sample Seurats
  VariableFeatures(HPC) <- SelectIntegrationFeatures(SampleList, nfeatures = 3000)

#run dim reduction on the combined Seurat, this time with Harmony
  set.seed(0) #set seed
  HPC <- RunPCA(HPC, assay = "SCT") %>% #run PCA
         RunHarmony(assay.use = "SCT", group.by.vars = "sample", #operate on SCT data, integrating across samples
                    max_iter = 10, early_stop = TRUE) %>% #max. iterations to run, unless optimized sooner
         FindNeighbors(reduction = "harmony", dims = 1:30) %>% #use new Harmony reduction
         FindClusters(algorithm = 2, resolution = 0.1) %>% #algorithm 2 = Louvain with multilevel refinement; use sensible `resolution`
         RunUMAP(reduction = "harmony", dims = 1:30, min.dist = 0.4, n.neighbors = 40) #run UMAP with sensible parameters
  
#take a look at combined dataset
  DimPlot(HPC, pt.size = 2) + ggtitle("Harmonized samples")
  
#remove `SampleList`
  rm(SampleList)
  
```

## *Step 3: Validation/cleanup*

Quickly check how well nuclei from different samples have integrated. First, look at UMAP by sample; then, check core QC features across UMAP too (\# counts per cell, \# features per cell, % mito. genes, SCT counts/features, & doublet score).

```{r integrate3.check}

#UMAP split by sample
  DimPlot(HPC, split.by = "sample", ncol = 3) + NoAxes() + theme(aspect.ratio = 1.5)

#plot several QC metrics as feature plots across UMAP dimensions; modify and combine
  plots <- FeaturePlot(HPC, features = c("nCount_RNA", "nFeature_RNA", "percent.mt", "nCount_SCT", "nFeature_SCT", "S.dbl"), combine = FALSE)
  for(i in seq_along(plots)) {plots[[i]] <- plots[[i]] + NoAxes() + NoLegend()} #remove axes and legends from all little plots
  plot_grid(plotlist = plots, ncol = 3) #plot together

#remove objects/variables no longer needed
  rm(i, plots)
    
```

QC metrics seem evenly distributed across visual clusters—looks good. Do some last cleanup/setup for the steps to come.

```{r integrate4.cleanup}

#remove duplicate metadata to avoid confusion
  HPC$orig.ident <- NULL #duplicated into simpler "sample"
  HPC$cluster <- HPC$seurat_clusters #copy to simpler name `cluster`
  HPC$seurat_clusters <- NULL

#remove SCT assay, no longer used; join RNA layers
  DefaultAssay(HPC) <- "RNA" #switch default to RNA
  HPC@assays$SCT <- NULL
  HPC[["RNA"]] <- JoinLayers(HPC[["RNA"]])
  
#only keep genes detected in any cells, post-filtering
  HPC <- subset(HPC, features = rownames(HPC)[rowSums(HPC[["RNA"]]$counts) > 0])

#normalize RNA assay to create `data` slot
  HPC <- NormalizeData(HPC) #use default `LogNormalize`
  
```

# **Assigning cell type**

Next up: determine which cells are which across the hippocampus. Do this by referencing an outside database from the Allen Brain Cell (ABC) Atlas: **MapMyCells**, available [here](https://brain-map.org/bkp/analyze/mapmycells). *(From here on, we'll refer to nuclei as "cells," for convenience.)*

## *MapMyCells: export*

To use MapMyCells, we upload our own data, and each cell is assigned its likeliest identity in reference to the Atlas at four taxonomic levels: class \> subclass \> supertype \> cluster.

Here, export data as a `.h5ad` file, which is required by MMC. (Not evaluated by default; run manually as needed.)

```{r ID1.export, eval = FALSE}

#export Seurat as .h5ad
  HPC.slim <- DietSeurat(HPC, assays = "RNA", layers = "counts", misc = FALSE) #slim down Seurat before exporting
  as.anndata(HPC.slim, file_path = ".", file_name = "MMC_HPC.h5ad", assay = "RNA",
             main_layer = "counts", #MMC expects raw counts data, not normalized
             other_layers = NULL, #only use counts layer to save space
             transer_dimreduc = FALSE) #don't copy over the dim. red. coordinates to save space
  rm(HPC.slim)
  
```

Next, outside of this script, upload the file to MapMyCells (link above). Use the **10x Whole Mouse Brain (CCN20230722)** reference taxonomy & **Hierarchical Mapping** algorithm, which is preferred by Allen scientists and is robust for snRNA-seq datasets.

## *MapMyCells: import*

*Return here once completed.* Load the validation log, then the results, and assign MMC info to cells here. (Adjust file names/paths accordingly, or change code below.)

```{r ID2.import}

#print the validation log
   str_split(read_file("MMC_HPC/validation_log.txt"), pattern = "\n")[[1]] #each line (\n) saved as new string in this vector

#load the results .csv
   MMC.results <- read.csv("MMC_HPC/MMC_HPC.csv", comment.char = "#") #skip first few lines of metadata, commented out by #
  
#add class, subclass, supertype, & cluster for each cell to Seurat; add cluster confidence as `MMC.confidence`
  HPC$MMC.class <-      MMC.results$class_name
  HPC$MMC.subclass <-   MMC.results$subclass_name
  HPC$MMC.supertype <-  MMC.results$supertype_name
  HPC$MMC.cluster <-    MMC.results$cluster_name
  HPC$MMC.confidence <- MMC.results$cluster_bootstrapping_probability

#check whether any clusters seem visually dominated by low-confidence mapped cells
  FeaturePlot_scCustom(HPC, features = "MMC.confidence", order = FALSE, pt.size = 1.5, colors_use = viridis_plasma_dark_high) +
                       ggtitle("MMC cluster confidence by cell") + NoAxes()
  
#remove objects/variables/etc.
  rm(MMC.results)
  
```

Good to see that no visual clusters are dominated by cells with low confidence in their MMC cluster assignment, suggesting that these clusters do represent meaningful cell types. Next, determine which is which.

## *MMC vs. clusters*

Filter out subclasses with very few cells assigned (\<`50`) and make a heatmap comparing remaining MMC subclasses with unbiased cluster assignments, to identify final cluster IDs.

```{r ID3.heatmap}

#set cutoff for how many cells a class/subclass must contain
  cutoff = 50

#extract list of subclasses that exceed cutoff; make new metadata assigning NA to cells not in these subclasses
  subclass.top.list <- table(HPC$MMC.subclass)[table(HPC$MMC.subclass) > cutoff] %>% names()
  HPC$MMC.subclass.filter <- HPC$MMC.subclass
  HPC$MMC.subclass.filter[-which(HPC$MMC.subclass %in% subclass.top.list)] <- NA
  
#view heatmap with reduced list
  heatmap(table(HPC$cluster, HPC$MMC.subclass.filter),
          main = "Seurat clusters vs. MMC subclasses", xlab = "MapMyCells mapping", ylab = "Seurat clustering", margins = c(12, 5))

#remove objects/variables/etc.
  rm(cutoff, subclass.top.list)
  
```

## *Cluster IDs*

Use heatmap to assign cell type/region IDs to each unbiased cluster.

```{r ID4.final}

#rename the clusters in an informed way
  HPC <- RenameIdents(HPC, "0" = "CA1", "1" = "DG", "2" = "parasubiculum I", "3" = "subiculum",
                      "4" = "CA3", "5" = "prosubiculum", "6" = "inhibitory I", "7" = "inhibitory II",
                      "8" = "parasubiculum II", "9" = "oligodendrocyte", "10" = "other glia")
  HPC$celltype <- Idents(HPC) #assign to new metadata `celltype`

#reorder the types for nice plotting
  type.levels <- c("DG", "CA1", "CA3", "prosubiculum", "parasubiculum I", "parasubiculum II", "subiculum",
                   "inhibitory I", "inhibitory II", "oligodendrocyte", "other glia")
  HPC$celltype <- factor(HPC$celltype)
  levels(HPC) = type.levels

#generate a nice set of colors for use in plotting by cell type
  HPC@misc$type <- DiscretePalette(24, palette = "stepped", shuffle = FALSE)
  HPC@misc$type <- HPC@misc$type[c(6, 1, 3, 12, 11, 10, 9, 13, 14, 17, 19)]
  
#quick plot to check out these new labels
  DimPlot(HPC, pt.size = 2, cols = HPC@misc$type) + NoAxes() + ggtitle("Final cell type assignments")

#remove objects/variables/etc.
  rm(type.levels)

```

# **IEG analysis setup**

## *IEG+/- classification*

Generate new metadata (+/-) for *Arc* and *c-fos* expression, where count \> `0` is considered positive. Also assign IEG intersections, where every cell is assigned one of the following: *Arc-cfos-*, *Arc+cfos-*, *Arc-cfos+*, or *Arc+cfos+*.

```{r IEG1.assign}

#new `ID` metadata slots with Arc/c-fos classification (if expression > 0)
  HPC$ID.Arc = "Arc-"
  HPC$ID.Arc[which(HPC[["RNA"]]$counts["Arc", ] > 0)] = "Arc+"
  HPC$ID.cfos = "cfos-"
  HPC$ID.cfos[which(HPC[["RNA"]]$counts["Fos", ] > 0)] = "cfos+"

#new metadata of Arc/c-fos intersections; make Ident
  HPC$Arc.cfos = "Arc-cfos-"
  HPC$Arc.cfos[which(HPC$ID.Arc == "Arc+" & HPC$ID.cfos == "cfos-")] = "Arc+cfos-"
  HPC$Arc.cfos[which(HPC$ID.Arc == "Arc-" & HPC$ID.cfos == "cfos+")] = "Arc-cfos+"
  HPC$Arc.cfos[which(HPC$ID.Arc == "Arc+" & HPC$ID.cfos == "cfos+")] = "Arc+cfos+"
  Idents(HPC) <- "Arc.cfos"
  
```

## *Subset DG*

We are focused on the dentate gyrus (DG), so subset DG cells based on `celltype` and `MMC.subclass`. Then, only keep genes detected in this subset of cells.

```{r IEG2.subset}

#subset DG cells from `HPC` based on celltype and MMC subclass, then clean up
  DG <- subset(HPC, subset = celltype == "DG") %>% subset(subset = MMC.subclass == "037 DG Glut")
  DG <- subset(DG, features = rownames(DG)[rowSums(DG[["RNA"]]$counts) > 0]) #only keep genes detected in DG
  
```

Re-run normalization, integration, etc. on the DG individually. Optimize UMAP parameters to loosen up structure and better display IEG+ cells.

```{r IEG3.revise}

#DG: run all the standard steps, same parameters as before unless noted
  set.seed(0)
  DG <- SCTransform(DG, vars.to.regress = "replicate") %>%
        RunPCA(assay = "SCT") %>%
        RunHarmony(assay.use = "SCT", group.by.vars = "replicate", max_iter = 10, early_stop = TRUE) %>%
        FindNeighbors(reduction = "harmony", dims = 1:30) %>%
        RunUMAP(reduction = "harmony", dims = 1:30, min.dist = 0.95, n.neighbors = 200) #adjust to loosen up structure
  DefaultAssay(DG) <- "RNA" #set default back to RNA assay
  DG@assays$SCT <- NULL #remove SCT assay
  
```

## *Visualize IEGs*

Take a look at *Arc*/*c-fos*+ cells across the DG, first on UMAP, then by % of cells, then in a Venn diagram of shared expression.

The last chunk in this section exports a `.csv` of the % *Arc*+ and *c-fos*+ cells, along with the total numbers represented in the Venn diagram, for reporting/plotting elsewhere. It is not automatically run; execute manually if needed.

```{r IEG4.dimplot}

#set up some useful labels/colors/etc,
  DG@misc$IEG.cla <- c("Arc+cfos+", "Arc-cfos+", "Arc+cfos-", "Arc-cfos-")
  DG@misc$IEG.col <- c("#0295FE", "#DE38E1", "#23A74E", "gray")
    
#plot with nice legend and labels
  plot1 <- DimPlot(DG, group.by = "Arc.cfos", pt.size = 3, order = DG@misc$IEG.cla) +
                   scale_color_manual(values = rev(DG@misc$IEG.col), labels = DG@misc$IEG.leg) + NoAxes() +
                   theme(plot.title = element_blank(), aspect.ratio = 1) + NoLegend() +
                   annotate("text", x = 5, y = -6.4, size = 10, label = paste0("n = ", glue({prettyNum(dim(DG)[2], big.mark = ",")}), " cells"))
  plot1 #print plot

```

```{r IEG5.percent}

#% of DG cells Arc+/c-fos+ by replicate
  stats.df <- data.frame() #initialize stats df
  for (id in c("ID.Arc", "ID.cfos")) { #loop through `ID.Arc` then `ID.cfos`
    Idents(DG) <- id
    stats <- Cluster_Stats_All_Samples(DG, group.by = "replicate")
    rownames(stats) <- stats$Cluster #copy +/- info to rows
    #from IEG+ row, grab first column + last X columns (X = # of reps)
    stats <- stats[levels(Idents(DG))[2], c((ncol(stats) - length(unique(DG$replicate)) + 1):ncol(stats))]
    stats.df <- rbind(stats.df, stats) #add to combined stats df
  }
  rm(id, stats)

#plot bar graph of averages and individual values by replicate
  stats.df <- as.data.frame(t(stats.df)) %>% pivot_longer(cols = everything()) #transpose then pivot longer
  IEG.avg <- stats.df %>% group_by(name) %>% summarize(avg = mean(value)) #average by IEG for bar plotting
  plot2 <- ggplot() + geom_bar(data = IEG.avg, aes(x = name, y = avg), stat = "identity",
                               fill = DG@misc$IEG.col[c(3,2)], width = 0.8) + #color by IEG
                      geom_point(data = stats.df, aes(x = name, y = value), #add individual points
                                 size = 4, shape = 21, fill = "white", color = "black", stroke = 1) +
                      scale_y_continuous(expand = c(0, 0), limits = c(0, 7), breaks = 1:6) + #set y range
                      theme_ggprism_mod() + theme(aspect.ratio = 2.25) +
                      theme(axis.text = element_text(size = 20), axis.title = element_text(size = 20)) + #adjustments
                      ylab("% DG cells") + theme(axis.title.x = element_blank()) #change/remove labels
  plot2 #print plot
  rm(IEG.avg) #remove objects/etc.

```

```{r IEG6.venn}

#determine percentages of Arc+/c-fos+ cells out of all Arc+/c-fos+
  pcts = c("Arc" = table(DG$Arc.cfos)[["Arc+cfos-"]] / sum(table(DG$Arc.cfos)[c("Arc+cfos-", "Arc-cfos+", "Arc+cfos+")]),
           "c-fos" = table(DG$Arc.cfos)[["Arc-cfos+"]] / sum(table(DG$Arc.cfos)[c("Arc+cfos-", "Arc-cfos+", "Arc+cfos+")]),
           "Arc&c-fos" = table(DG$Arc.cfos)[["Arc+cfos+"]] / sum(table(DG$Arc.cfos)[c("Arc+cfos-", "Arc-cfos+", "Arc+cfos+")]))
  pcts[1:length(pcts)] <- (prettyNum(pcts * 100, digits = 3) %>% as.numeric())
  
#plot Venn diagram of the intersection of Arc+/c-fos+ cells, plus an unlabeled copy
  plot3 <- plot_grid(plot(euler(pcts), lty = 0, quantities = list(cex = 2), labels = NULL, fills = DG@misc$IEG.col[3:1]),
                     plot(euler(pcts), lty = 0, quantities = NULL, labels = NULL, fills = DG@misc$IEG.col[3:1]))
  plot3 #print plot
  rm(pcts) #remove objects/etc.

```

``` {r IEG.export, eval = FALSE}

#export actual values from plots above, for separate plotting if desired
  stats.df$replicate <- rep(1:length(table(DG$replicate)), each = 2) #add replicate info to df of % data
  stats.df <- pivot_wider(stats.df) %>% round(2) #convert back to wide format for export; round off
  for (i in 2:3) colnames(stats.df)[i] = paste0("%", colnames(stats.df)[i]) #add "%" to column names to clarify
  stats.df$`#Arc+cfos-` = table(DG$replicate, DG$Arc.cfos)[, "Arc+cfos-"] #add # of cells by replicate for each Venn subset
  stats.df$`#Arc+cfos+` = table(DG$replicate, DG$Arc.cfos)[, "Arc+cfos+"]
  stats.df$`#Arc-cfos+` = table(DG$replicate, DG$Arc.cfos)[, "Arc-cfos+"]
  write.csv(stats.df, "N-Arc-cfos-percents-counts.csv", row.names = FALSE) #export
  rm(i, stats.df) #remove once exported (will hang around if this chunk is not run -- oh well)
  
```

# **Differential expression**

## *Arc & c-fos DEGs*

Find differentially expressed genes (DEGs) between *Arc*+ and *Arc*- cells, and then between *c-fos*+ and *c-fos*- cells. Use sensible cutoffs for adjusted p-values and fold changes.

Here, significant DEGs have `-log10(padj)` \> `5`, equivalent to **adj. *p* \< `0.00001`**, and \|`log2FC`\| \> `0.5`, equivalent to a **fold change of \> `~40%`**, up or down.

```{r DEG1.find}

#set cutoffs for significance & fold change
  padj.cutoff = 5
  fold.cutoff = 0.5
  
#Arc+ vs. Arc- DEGs
  Idents(DG) <- "ID.Arc"
  Arc.DEGs <- FindMarkers(DG, ident.1 = "Arc+", ident.2 = "Arc-", logfc.threshold = 0) %>% #test all genes (default = 0.1)
                          mutate(log10_padj = -log10(p_val_adj)) #add -log10(adj. p) column for filtering
  Arc.DEGs$log10_padj[is.infinite(Arc.DEGs$log10_padj)] = 300 #some adj. p-values are infinite, so set to a cap of 300

#c-fos+ vs. c-fos- DEGs
  Idents(DG) <- "ID.cfos"
  cfos.DEGs <- FindMarkers(DG, ident.1 = "cfos+", ident.2 = "cfos-", logfc.threshold = 0) %>% #test all genes (default = 0.1)
                           mutate(log10_padj = -log10(p_val_adj)) #add -log10(adj. p) column for filtering
  cfos.DEGs$log10_padj[is.infinite(cfos.DEGs$log10_padj)] = 300 #some adj. p-values are infinite, so set to a cap of 300

```

Plot DEGs on volcano plots. Here we write a custom plot function, then use it for both *Arc*+ vs. *Arc*- and *c-fos*+ vs. *c-fos*- analyses.

The function labels all of the top `X` number of upregulated genes (here, `40`) in positive cells, but labels in a distinct way the genes that are *unique* to the given positive cells in contrast to those in the positive cells of the other comparison.

```{r DEG2.volcano.fun}

########################################.
#create function to generate a volcano plot for gene1+ vs -, identifying genes unique between that comparison and another comparison (gene2+ vs -)
  #'inputs: [1] @param gene1: first gene name; [2] @param gene2: second gene name;
  #'        [3] @param gene1.DEGs: list of DEGs from `FindMarkers()` with `log10_padj` added for gene1+ vs -; [4] @param gene2.DEGs: same for gene2+ vs -;
  #'        [5] @param padj.cut: padj cutoff for labeling on plot; [6] @param fold.cut: fold change cutoff for labeling on plot;
  #'        [7] @param num.top: number of top genes within which to make unique comparisons for gene1+ vs - / gene2+ vs -;
  #'        [8] @param col.UP: color to use for upregulated genes -- downregulated is black, nonsignificant is gray;
  #'        [9] @param y.range: range to use for padj on plot; [10] @param x.range: range to use for fold change on plot;
  #'        [11] @param repel: set of 4 repel parameters as such: `c(force, nudge_x, nudge_y, max.overlaps)`
  #'output: [1] labeled volcano plot
########################################.

intersect.volcano <- function(gene1, gene2, gene1.DEGs, gene2.DEGs, padj.cut, fold.cut,
                              num.top, col.UP, y.range, x.range, repel) {
  #remove `gene1` from its own DEG list
    gene1.DEGs <- gene1.DEGs[!(rownames(gene1.DEGs) %in% gene1), ] #gene1 upregulated by definition

  #grab lists of top `num.top` genes UP
    gene1.DEGs.UP.top <- filter(gene1.DEGs, log10_padj > padj.cut & avg_log2FC > fold.cut) %>% head(n = num.top)
    gene2.DEGs.UP.top <- filter(gene2.DEGs, log10_padj > padj.cut & avg_log2FC > fold.cut) %>% head(n = num.top)

  #set color parameters for plotting
    gene1.DEGs$color <- "gray" #set everything to gray to start
    gene1.DEGs[gene1.DEGs$avg_log2FC < -fold.cut, ]$color <- "black" #then make all downregulated genes black
    gene1.DEGs[gene1.DEGs$avg_log2FC > fold.cut, ]$color <- col.UP #then make all upregulated genes `col.UP`
    gene1.DEGs[gene1.DEGs$log10_padj < padj.cut, ]$color <- "gray" #last, return any gene with too low of a p-value to gray

  #add extra parameters for top genes to be plotted
    gene1.DEGs.UP.top$textcolor = "black" #make all text black by default
    gene1.DEGs.UP.top$fill = NA #make all fills empty by default
    gene1.DEGs.UP.top$label <- rownames(gene1.DEGs.UP.top) #add rownames as text labels to be plotted
    gene1.DEGs.UP.top[!(rownames(gene1.DEGs.UP.top) %in% rownames(gene2.DEGs.UP.top)), ]$textcolor <- "white" #for genes not in `gene2.DEGs.UP.top`, change text color
    gene1.DEGs.UP.top[!(rownames(gene1.DEGs.UP.top) %in% rownames(gene2.DEGs.UP.top)), ]$fill <- col.UP #for genes not in `gene2.DEGs.UP.top`, change fill to `col.UP`
    gene1.DEGs.UP.top[gene2, ]$textcolor = "black" #change back `gene2`, as it was removed from `gene2.DEGs.UP.top` so shows up (artificially) unique
    gene1.DEGs.UP.top[gene2, ]$fill = NA
  
  #plotting volcano plot
    ggplot(gene1.DEGs) + theme_cowplot() +
           geom_hline(yintercept = padj.cut, linetype = "dashed", color = "gray") + #horizontal cutoff line
           geom_vline(xintercept = c(fold.cut, -fold.cut), linetype = "dashed", color = "gray") + #vertical cutoff lines, positive and negative
           geom_vline(xintercept = 0, color = "black") + geom_hline(yintercept = 0, color = "black") + #y-axis & x-axis
           geom_point(aes(x = avg_log2FC, y = log10_padj), shape = 16, size = 2.5, color = gene1.DEGs$color, alpha = 0.5) + #add all points
           scale_x_continuous(name = expression("log"[2]*"(fold change)"), limits = x.range, breaks = breaks_pretty(n = 10)) + #x-axis settings
           scale_y_continuous(name = expression("-log"[10]*"adj. "*italic("p")*"\u00advalue"), limits = y.range, breaks = breaks_pretty(n = 6)) + #y-axis settings
           theme(title = element_blank(), axis.title = element_text(size = 20), axis.text = element_text(size = 18), #text settings
                 axis.title.x = element_text(vjust = -1), axis.title.y = element_text(vjust = +1.5)) +
           geom_point(data = gene1.DEGs.UP.top[1:num.top, ], aes(x = avg_log2FC, y = log10_padj), #add top gene highlight points on top of old points
                      shape = 21, size = 2.5, fill = col.UP, color = "black") + 
           geom_label_repel(data = gene1.DEGs.UP.top[1:num.top, ], aes(x = avg_log2FC, y = log10_padj, label = label), #add labels for top genes/unique top genes
                            size = 7.5, label.size = NA, fill = gene1.DEGs.UP.top$fill, color = gene1.DEGs.UP.top$textcolor,
                            segment.alpha = 0.5, segment.color = "black", seed = 1, #label line settings & seed
                            force = repel[1], nudge_x = repel[2], nudge_y = repel[3], max.overlaps = repel[4]) #label repel settings
}

```

```{r DEG3.volcano.plot}

#use function to generate plots: Arc+ vs - first
  plot4 <- intersect.volcano(gene1 = "Arc", gene2 = "Fos", gene1.DEGs = Arc.DEGs, gene2.DEGs = cfos.DEGs,
                             padj.cut = padj.cutoff, fold.cut = fold.cutoff, col.UP = DG@misc$IEG.col[3],
                             num.top = 40, x.range = c(-4, 6), y.range = c(0, 225), repel = c(100, -2, 50, 25)) + theme(aspect.ratio = 1)
  plot4
  
#then c-fos+ vs -
  plot5 <- intersect.volcano(gene1 = "Fos", gene2 = "Arc", gene1.DEGs = cfos.DEGs, gene2.DEGs = Arc.DEGs,
                             padj.cut = padj.cutoff, fold.cut = fold.cutoff, col.UP = DG@misc$IEG.col[2],
                             num.top = 40, x.range = c(-3, 6.5), y.range = c(0, 350), repel = c(100, -2, 50, 25)) + theme(aspect.ratio = 1)
  plot5

```

To examine the extent of shared/unique DEGs, generate a Venn diagram of those from each comparison, for both upregulated and downregulated genes. Combine the two diagrams into one plot, scaled approximately proportionally to their # of genes.

```{r DEG4.venn}

#some jitter involved in plotting, so set seed
  set.seed(0)

#get UP/DOWN DEGs and plot Venn of # shared/unique genes; also used in next chunk
  Arc.DEGs.UP <- rownames(filter(Arc.DEGs, log10_padj > padj.cutoff & avg_log2FC > fold.cutoff)) #grab gene UP names (Arc)
  cfos.DEGs.UP <- rownames(filter(cfos.DEGs, log10_padj > padj.cutoff & avg_log2FC > fold.cutoff)) #grab gene UP names (c-fos)
  Arc.DEGs.DN <- rownames(filter(Arc.DEGs, log10_padj > padj.cutoff & avg_log2FC < -fold.cutoff)) #grab gene DOWN names (Arc)
  cfos.DEGs.DN <- rownames(filter(cfos.DEGs, log10_padj > padj.cutoff & avg_log2FC < -fold.cutoff)) #grab gene DOWN names (c-fos)

  venn.UP <- euler(c("Arc" = length(Arc.DEGs.UP) - length(Arc.DEGs.UP[Arc.DEGs.UP %in% cfos.DEGs.UP]), #Venn of UP genes
                     "c-fos" = length(cfos.DEGs.UP) - length(Arc.DEGs.UP[Arc.DEGs.UP %in% cfos.DEGs.UP]),  
                     "Arc&c-fos" = length(Arc.DEGs.UP[Arc.DEGs.UP %in% cfos.DEGs.UP]))) #same as using c-fos lists (just getting shared #)
  venn.DN <- euler(c("Arc" = length(Arc.DEGs.DN) - length(Arc.DEGs.DN[Arc.DEGs.DN %in% cfos.DEGs.DN]), #Venn of DOWN genes
                     "c-fos" = length(cfos.DEGs.DN) - length(Arc.DEGs.DN[Arc.DEGs.DN %in% cfos.DEGs.DN]),
                     "Arc&c-fos" = length(Arc.DEGs.DN[Arc.DEGs.DN %in% cfos.DEGs.DN]))) #same as using c-fos lists (just getting shared #),
  
#plot Venns of # shared/unique genes UP or DOWN, then merge together
  plot6 <- plot_grid(plot(venn.UP, lty = 0, quantities = list(cex = 2.5), labels = NULL, fills = DG@misc$IEG.col[3:1]),
                     plot(venn.UP, lty = 0, quantities = NULL, labels = NULL, fills = DG@misc$IEG.col[3:1]), #add an unlabeled copy
                     plot(venn.DN, lty = 0, quantities = list(cex = 2.5), labels = NULL, fills = DG@misc$IEG.col[3:1]),
                     plot(venn.DN, lty = 0, quantities = NULL, labels = NULL, fills = DG@misc$IEG.col[3:1]),#add an unlabeled copy
                     ncol = 2, rel_heights = c(2*sqrt(length(Arc.DEGs.UP)/3.14159), 2*sqrt(length(Arc.DEGs.DN)/3.14159))) #scale plots roughly by proportionate area
  plot6 #print plot
  rm(Arc.DEGs.UP, cfos.DEGs.UP, Arc.DEGs.DN, cfos.DEGs.DN) #remove DEG lists
  rm(venn.UP, venn.DN) #remove Venns
  
```

## *Arc & c-fos GO pathways*

Export `.csv` files of all genes upregulated in *Arc* and *c-fos* analyses. These lists will be independently uploaded to the [ShinyGO](https://bioinformatics.sdstate.edu/go/) web interface to identify enriched functional pathways in each case (further detailed in **Methods**). To avoid overwriting, this chunk is not automatically run.

```{r DEG5.GO, eval = FALSE}

#export Arc/c-fos UP as .csv files
  write.csv(rownames(filter(Arc.DEGs, log10_padj > padj.cutoff & avg_log2FC > fold.cutoff)), "R-DEGs-Arc-UP.csv", row.names = FALSE)
  write.csv(rownames(filter(cfos.DEGs, log10_padj > padj.cutoff & avg_log2FC > fold.cutoff)), "S-DEGs-cfos-UP.csv", row.names = FALSE)

#remove objects/etc. now that plotting is done
  rm(padj.cutoff, fold.cutoff, Arc.DEGs, cfos.DEGs, intersect.volcano)
  
```

# **Export plots**

Export all plots, titled with reference to their final figure panels. Again, this chunk is not run by default—run manually if desired.

```{r export, eval = FALSE}

#UMAP
  pdf(file = "UMAP-Arc-cfos.pdf", width = 7.5, height = 7.5)
  plot1
  dev.off()

#Figure 1N
  pdf(file = "N-Arc-cfos-percent-Venn.pdf", width = 7.5, height = 7.5)
  plot_grid(plot2, plot3, ncol = 1, rel_heights = c(2, 1))
  dev.off()

#Figure 1O
  pdf(file = "O-Arc-DEGs-volcano.pdf", width = 7.5, height = 7.5)
  plot4
  dev.off()
  
#Figure 1P
  pdf(file = "P-cfos-DEGs-volcano.pdf", width = 7.5, height = 7.5)
  plot5
  dev.off()
  
#Figure 1Q
  pdf(file = "Q-Arc-cfos-DEGs-Venn.pdf", width = 15, height = 7.5) #make twice as wide to fit unlabeled copies
  plot6
  dev.off()
  
```

# **Session info**

Print session info for reproducibility.

```{r session.info}

  sessionInfo()

```
